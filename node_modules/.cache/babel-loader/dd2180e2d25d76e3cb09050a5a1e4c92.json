{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getIn = getIn;\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nfunction getIn(schema, path, value) {\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : value;\n  var parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n\n    if (schema.innerType) {\n      var idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(\"Yup.reach cannot resolve an array item at index: \".concat(_part, \", in the path: \").concat(path, \". \") + \"because there is no value at that index. \");\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \".concat(path, \". \") + \"(failed at: \".concat(lastPartDebug, \" which is a type: \\\"\").concat(schema._type, \"\\\")\"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nvar _default = reach;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","getIn","_propertyExpr","require","trim","part","substr","length","schema","path","context","parent","lastPart","lastPartDebug","parentPath","forEach","_part","isBracket","isArray","resolve","innerType","idx","parseInt","Error","fields","_type","reach","obj","_default"],"sources":["/home/father/bookstore/frontend/node_modules/yup/lib/util/reach.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getIn = getIn;\n\nvar _propertyExpr = require(\"property-expr\");\n\nlet trim = part => part.substr(0, part.length - 1).substr(1);\n\nfunction getIn(schema, path, value, context = value) {\n  let parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent,\n    parentPath: path,\n    schema\n  };\n  (0, _propertyExpr.forEach)(path, (_part, isBracket, isArray) => {\n    let part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context,\n      parent,\n      value\n    });\n\n    if (schema.innerType) {\n      let idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema._type}\")`);\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema,\n    parent,\n    parentPath: lastPart\n  };\n}\n\nconst reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;\n\nvar _default = reach;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}